import numpy as np
import pdb

def gen_random_map(shape):
    """Generate a random mapping for randomized linearization, as a dict
        Input should be the shape of the active area of the ising grid
        (not including boundaries)
    """
    (x,y) = shape
    size = x * y
    linearIndices = np.array([ i for i in range (size) ])
    xInd,yInd = np.meshgrid(list(range(x)), list(range(y)))
    rectIndices = list(zip(np.ravel(xInd),np.ravel(yInd)))

    randomIndices = np.random.shuffle(linearIndices)
    assert len(randomIndices) == len(rectIndices)

    randMap = np.empty(shape,dtype=np.int32)
    i = 0
    for (i,j) in rectIndices:
        randMap[i,j] = randomIndices[i]
        i += 1
    return randMap

# A.k.a cache destroyer (?)
def random_linearize(frame, mapping):
    """Apply a random mapping to a frame to get a linear numpy array
    
    Random mapping is an array of the same size as frame with integer entries
    that tell which linear entry the 
    """
    linBuf = np.empty(len(mapping))
    (x,y) = np.shape(frame)
    xInd,yInd = np.meshgrid(list(range(x)), list(range(y)))
    rectIndices = list(zip(np.ravel(xInd),np.ravel(yInd)))

    for (i,j) in rectIndices:
        linBuf[mapping[i,j]] = frame[i,j]
    return linBuf

def rowmajor_linearize(frame):
    """Linearize the frame in row-major order"""
    return np.ravel(frame,order="C")

def colmajor_linearize(frame):
    """Linearize the frame in column-major order"""
    return np.ravel(frame,order="F")

# Code for this nicked off Wikipedia https://en.wikipedia.org/wiki/Hilbert_curve
def rot(n, x, y, rx, ry):
    if ry == 0:
        if rx == 1:
            x = n-1 - x
            y = n-1 - y
        (x,y) = (y,x)
    return (x,y)

def gen_hcurve(size):
    """Generate the mapping for a Hilbert curve of a particular shape.

    Returns the hilbert curve mapping for a square of size 2^size on either 
    side."""

    if np.floor(np.log2(size)) != np.ceil(np.log2(size)):
        raise ValueError("Input must be a power of 2")
    herp = np.zeros((size,size),dtype=np.int32)

    rx = 0
    ry = 0
    s = 0
    for y in range(size):
        for x in range(size):
            xloc = x  # Avoid screwing up the loop counters
            yloc = y
            d = 0
            s = size//2
            while s > 0:
                rx = 1 if xloc & s > 0 else 0
                ry = 1 if yloc & s > 0 else 0
                d += s * s * ((3 * rx) ^ ry)
                (xloc,yloc) = rot(s, xloc, yloc, rx, ry);
                s //= 2
            herp[x,y] = d
    return herp

def spacefill_linearize(frame, curveMap):
    """Linearize the frame with a Hilbert Curve.

    Specifically, if the frame is square with size 2^n on each side, we
    linearize it by the n-th order Hilbert curve.
    
    curveMap should be generated by gen_hcurve, this is done for efficiency
    """

    (x,y) = np.shape(frame)
    if np.shape(frame) != np.shape(curveMap):
        raise ValueError("Frame and mapping should be same size")

    linear = np.empty(np.size(frame))

    for (x,y),linIndex in np.ndenumerate(curveMap):
        print(linIndex,x,y)
        linear[linIndex] = frame[x,y]

    return linear
