# This module determines the compression ratio of a given state.
import numpy as np
import lzma
import bitstring
import pickle

import spintolinear

lzmaFilters = [
    {"id": lzma.FILTER_LZMA2, "preset": 7 | lzma.PRESET_EXTREME},
]

# trace: raw trace of ising models, generated by numpy
# 
class CompressionData:
    def __init__(self, trace, layout, packingType):
        self.frameshape = np.shape(trace[0])
        self.numFrames = len(trace)
        self.numel = self.frameshape[0] * self.frameshape[1] * self.numFrames
        if packingType == "bit" or packingType == "byte":
            self.packingType = packingType
        else:
            raise ValueError("packingType is invalid, must be 'bit' or 'byte'")
        self.layout = layout
        self.bindata = self.gen_bin_data(trace)

        self.cachedCd = None
        self.cachedC0 = None
        self.cachedC1 = None

    def gen_bin_data(self, trace):
        """Generate the raw binary data for compression"""
        linearized = spintolinear.linearize_frames(trace,self.layout) + 1
        if self.packingType == "bit":
            return bitstring.Bits(linearized).tobytes()
        else:
            return linearized.tobytes()

    def gen_zeros_data(self):
        """Generate the all-zeros string for compression ratio measurements"""
        if self.packingType == "bit":
            return np.zeros(self.numel//8 + 1).tobytes()
        else:
            return np.zeros(self.numel).tobytes()

    def gen_random_data(self):
        """Generate the random string for compression ratio measurements"""
        rand = np.random.randint(2,size=self.numel)
        if self.packingType == "bit":
            return bitstring.Bits(rand).tobytes()
        else:
            return rand.tobytes()

    def size_data(self):
        if self.cachedCd is None:
            print("Compressing Sample Data...please be patient")
            self.cachedCd = self.compressed_data_size(self.bindata)
        return self.cachedCd

    def size_zeros(self):
        if self.cachedC0 is None:
            self.cachedC0 = self.compressed_data_size(self.gen_zeros_data())
        return self.cachedC0

    def size_random(self):
        if self.cachedC1 is None:
            print("Compressing Random Data...please be patient")
            self.cachedC1 = self.compressed_data_size(self.gen_random_data())
#            print("Random Data compressed.")
        return self.cachedC1

    def compressed_data_size(self, obj):
        """Get size of compressed data. Input needs to be a bytearray."""
        compressedStateData = lzma.compress(obj, 
                                    format=lzma.FORMAT_RAW,
                                    check=lzma.CHECK_NONE,
                                    preset=None,
                                    filters=lzmaFilters)
        return len(compressedStateData)

    def get_compression_ratios(self):
        """Compute compression ratio of data in system."""
        C_d = self.size_data()
        C_0 = self.size_zeros()
        C_1 = self.size_random()
        eta = (C_d - C_0) / (C_1 - C_0)

        return eta

import sys
if __name__ == '__main__':
    try:
        linType = sys.argv[1]
        packType = sys.argv[2]
        infile = sys.argv[3]
    except:
        print("Usage: %s <linear mapping type> <bit/byte> <pickle file>"%sys.argv[0])
        print("""Linear mapping type controls linearization: row, col, spacefill
                , spiral, and random are valid values.""")
        print("bit/byte are literal strings and control whether bits or bytes are used")
        sys.exit(1)
    
    with open(infile,'rb') as pklfile:
        trace = pklfile.load()

    compressor = CompressionData(trace, linType, packType)
    print("With input of " + infile + ", compression ratio is " + compressor.get_compression_ratios())