# This module determines the compression ratio of a given state.
import numpy as np
import lzma
import bitstring
import pickle
import pdb
import re

import spintolinear

lzmaFilters = [
    {"id": lzma.FILTER_LZMA2, "preset": 7 | lzma.PRESET_EXTREME},
]

# trace: raw trace of ising models, generated by numpy
# 
class CompressionData:
    def __init__(self, trace, layout, packingType):
        self.frameshape = np.shape(trace[0])
        self.numFrames = len(trace)
        if packingType == "bit" or packingType == "byte":
            self.packingType = packingType
        else:
            raise ValueError("packingType is invalid, must be 'bit' or 'byte'")
        self.layout = layout
        self.bindata = self.gen_bin_data(trace)
        self.nbytes = len(self.bindata)

        self.cachedCd = None
        self.cachedC0 = None
        self.cachedC1 = None

    def gen_bin_data(self, trace):
        """Generate the raw binary data for compression"""
        linearized = spintolinear.linearize_frames(trace,self.layout) + 1
        if self.packingType == "bit":
            return bitstring.Bits(linearized).tobytes()
        else:
            return linearized.tobytes()

    def gen_zeros_data(self):
        """Generate the all-zeros string for compression ratio measurements"""
        item = np.zeros(self.nbytes,dtype=np.int8).tobytes()
        assert len(item) == len(self.bindata)
        return item

    def gen_random_data(self):
        """Generate the random string for compression ratio measurements"""
        if self.packingType == "bit":
            rand = np.random.randint(2,size=8*self.nbytes ,dtype=np.int8)
            item = bitstring.Bits(rand).tobytes()
        else:
            rand = np.random.randint(2,size=self.nbytes,dtype=np.int8)
            item = rand.tobytes()
        assert len(item) == len(self.bindata)
        return item

    def size_data(self):
        if self.cachedCd is None:
            self.cachedCd = self.compressed_data_size(self.bindata)
        return self.cachedCd

    def size_zeros(self):
        if self.cachedC0 is None:
            self.cachedC0 = self.compressed_data_size(self.gen_zeros_data())
        return self.cachedC0

    def size_random(self):
        if self.cachedC1 is None:
            self.cachedC1 = self.compressed_data_size(self.gen_random_data())
#            print("Random Data compressed.")
        return self.cachedC1

    def compressed_data_size(self, obj):
        """Get size of compressed data. Input needs to be a bytearray."""
        compressedStateData = lzma.compress(obj, 
                                    format=lzma.FORMAT_RAW,
                                    check=lzma.CHECK_NONE,
                                    preset=None,
                                    filters=lzmaFilters)
        return len(compressedStateData)

    def get_compression_ratios(self):
        """Compute compression ratio of data in system."""
        C_d = self.size_data()
        C_0 = self.size_zeros()
        C_1 = self.size_random()
        eta = (C_d - C_0) / (C_1 - C_0)

        return eta

import sys
if __name__ == '__main__':
    try:
        linType = sys.argv[1]
        packType = sys.argv[2]
        infile = sys.argv[3]
    except:
        print("Usage: %s <linear mapping type> <bit/byte> <pickle file>"%sys.argv[0])
        print("""Linear mapping type controls linearization: row, col, spacefill
                , spiral, and random are valid values.""")
        print("bit/byte are literal strings and control whether bits or bytes are used")
        sys.exit(1)
    
    with open(infile,'rb') as pklfile:
        trace = pickle.load(pklfile)

    # A hardcoded filename parsing to get temperatures (sloppy)
    # Note: get T before compression so that we know before doing work if this
    # is going to screw up or not
    match = re.search("-(\d+\.\d+)",infile)
    if match is None:
        raise ValueError("Could not parse temperature from filename.")
    T = match.group(1)

    compressor = CompressionData(trace, linType, packType)

    ratio = compressor.get_compression_ratios()

    with open("ratio"+"-"+T+"-"+linType+"-"+packType+".txt",'w') as outfile:
        outfile.write("T (J/kB) = " + T + ", ")
        outfile.write("Linearization layout = " + linType + ", ")
        outfile.write("Bit/Byte per site = " + packType + ", ")
        outfile.write("Resulting compression ratio = " + str(ratio) + "\n")

    print("Results: T=" + T + ", layout=" + linType + ", bb=" + packType + ", ratio=" + str(ratio))
    print("Raw data size=" + str(len(compressor.bindata)), ",Cd =" + str(compressor.size_data()) +\
            ",C0 = " + str(compressor.size_zeros()) + ",C1 = " + str(compressor.size_random()) )